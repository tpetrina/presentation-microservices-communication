import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer";
import { github, vsDark, nightOwl } from "@code-surfer/themes";
import Layout from "./src/Layout";
import LocalImage from "./src/LocalImage";
import './main.css';

export const theme = nightOwl;

<Layout>

# Information patterns for microservice architecture

Toni Petrina <br/>
Lead SRE <br/>
Visma e-conomic <br/>

<span style={{ color: "" }}>SDD Conf 2024, London</span>

</Layout>

---

<Layout style={{alignSelf: 'start'}}>

## Agenda

- What changed with microservices?
- REST, eventual consistency and actors
- Where is our data?
- Recap

</Layout>

---

## What this talk is not about?

- Introduction to microservices
- Arguing for or against microservices

---

<CodeSurfer>

```js title="A procedural mindset"
function (model: CreateUserModel) {
    // first we create a new user in our main DB
    user = db.insertUser(model);

    // user has accepted to join organization
    db.addToOrganization(user, model.organizationId);

    // then we connect it to our external CRM used for tracking
    crm.connectUser(user.id, model);

    // don't forget to send welcome or confirmation email
    mail.sendConfirmEmail(user.email);

    // set-up for compaign
    campaign.setNewUser(user.id, new Date());
}
```

</CodeSurfer>

---

<CodeSurfer>

```js title="Original requirement"
function (model: CreateUserModel) {
    // first we create a new user in our main DB
    user = db.insertUser(model);

    // user has accepted to join organization
    db.addToOrganization(user, model.organizationId);
}
```

</CodeSurfer>

---

<CodeSurfer>

```js title="CRM integration added"
function (model: CreateUserModel) {
    // first we create a new user in our main DB
    user = db.insertUser(model);

    // user has accepted to join organization
    db.addToOrganization(user, model.organizationId);

    // then we connect it to our external CRM used for tracking
    crm.connectUser(user.id, model);
}

```

</CodeSurfer>

---

<CodeSurfer>

```js title="New feature: confirmation email"
function (model: CreateUserModel) {
    // first we create a new user in our main DB
    user = db.insertUser(model);

    // user has accepted to join organization
    db.addToOrganization(user, model.organizationId);

    // then we connect it to our external CRM used for tracking
    crm.connectUser(user.id, model);

    // don't forget to send welcome or confirmation email
    mail.sendConfirmEmail(user.email);
}
```

</CodeSurfer>

---

<CodeSurfer>

```js title="New feature: campaign tracker"
function (model: CreateUserModel) {
    // first we create a new user in our main DB
    user = db.insertUser(model);

    // user has accepted to join organization
    db.addToOrganization(user, model.organizationId);

    // then we connect it to our external CRM used for tracking
    crm.connectUser(user.id, model);

    // don't forget to send welcome or confirmation email
    mail.sendConfirmEmail(user.email);

    // set-up for compaign
    campaign.setNewUser(user.id, new Date());
}
```

</CodeSurfer>

---

<Layout>

# Simple approach, complex outcomes

- Transactions on system boundary
  - Everything happens at once - all or nothing
  - High coupling => system is in a consistent state
- <span style={{ color: "green" }}>&#9650;</span> All components share same availability
- <span style={{ color: "green" }}>&#9650;</span> Procedure can be as complex as
  possible, all data is available
- ðŸ”» Rouge component can bring down the system

</Layout>

---

## SQL schema...and probably code

<LocalImage src="sql.png" />

---

<Layout>

# From monolith to services

The goal is to transform the monolithic codebase into a microservice one. <br/>
How does that change the above code?

</Layout>

---

# Microservices are:

<Layout>

- Highly maintainable and testable
- <span style={{ color: "green" }}>Loosely coupled</span>
- Independently deployable
- <span style={{ color: "green" }}>Organized around business capabilities</span>
- Owned by a small team

(from [microservices.io](https://microservices.io))

</Layout>

---

# Two problems

1. How do we _perform_ actions when components are distributed?
2. How do we _get_ data out of distributed systems?

---

<Layout>

# Performing actions

- When a user initiates action
  - When is it done?
  - How to handle failure?

</Layout>

---

# Within a service

<LocalImage src="images/monolith.png" width="800px" />

---

# Sync architecture (request/response)

<LocalImage src="images/request-driven.png" width="800px" />

---

# Single subsystem failure fails the request

<LocalImage src="images/request-driven-error.png" width="800px" />

---

<Layout>

# Transactional boundary does not include external services

- We can always roll-back changes made in the local db
- Use Outbox pattern within transaction for external services
- E.g. sending an e-mail mid-operation which gets rolled back

</Layout>

---

<Layout>

# Transactions over multiple systems

- Distributed Transactions
- Two-phase commit
- Saga

</Layout>

---

## Events decouple subsystems and failures

<LocalImage src="images/event-driven.png" width="800px" />

---

<Layout>

# Always emit events with Outbox pattern

Outbox pattern allows for:

- Persist events before sending them
- If transactional, simulates transaction with external services
- Allows retries and observability
- Ensures at least once deliverability

</Layout>

---

<CodeSurfer>

```js title="Event code"
function (model: CreateUserModel) {
    // First we create a new user in our main DB
    user = db.insertUser(model);

    // User has accepted to join organization
    db.addToOrganization(user, model.organizationId);

    // Add event to Outbox and process it later
    outbox.AddEvent(new UserCreatedEvent(user.Id));
}
```

</CodeSurfer>

---

<Layout>

# Events are not a panacea

- Switching from request/response to events might yield some new issues
- We knew that when the request finished, everything was "correct"
- Events will be delivered...when?

</Layout>

---

<Layout>

# 1. Eventual consistency

Issues:

- "User created, but can't login"
- Data changed, but UI doesn't reflect it

Solve with:

- Sync write to read model in the same transaction
- Better UX (OK vs Accepted HTTP Status Code)
- Learn to live with it - the world is eventually consistent

</Layout>

---

<Layout>

# 2. Thundering herd and backpressure

<blockquote>
  In computer science, the thundering herd problem occurs when a large number of
  processes or threads waiting for an event are awoken when that event occurs,
  but only one process is able to handle the event. When the processes wake up,
  they will each try to handle the event, but only one will win. All processes
  will compete for resources, possibly freezing the computer, until the herd is
  calmed down again.[1]
</blockquote>

- Subscribers must handle the load from producer
  - Could you handle Twitter load on your service in real time?

Solve with:

- Backpressure and limiting on queue ingestion

</Layout>

---

<Layout>

## 3. Observability

<LocalImage src="images/events-must-flow.jpg" width="800px" />

</Layout>

---

<Layout>

## 3. Observability

Detect:

- Events not being processed
- Events being processed slowly

Solve with:

- Synthetic tests to ensure a "stream" of events to process

</Layout>

---

<LocalImage src="images/control-system.png" width="800px" />

---

<Layout>

## 4. Temporal decoupling i.e. it is done when it is done

- Not all operations "complete" at the same time. Depends on number of listeners and scale on those subsystems
  - The slowest sub-operation slows down the entire operation
- You might build a copy of a workflow engine
- Good reason to start using sagas in case of failures
  - Or at least compensating operations
  - Invest in customer support

</Layout>

---

<Layout>

## 5. Distant failures

- How to notify user when event handling fails?
  - Can user even do anything about them?
- Can we resolve them _through support_?
- Need to show "ongoing" operations
- All UX issues become business issues
- At-least-once and idempotency ensure trivial retry without duplicating stuff

</Layout>

---

## Message queue in front of each service

<LocalImage src="images/event-driven-queue.png" width="800px" />

---

<Layout>

## Queues are not the answer

- Processing speed
- Parallelization
- Retries and error handling

Think about:

- Message streams (e.g. Kafka)
- Poll model for recovery (e.g. Atom feeds)

</Layout>

---

## Data requirements

- Event was received, but does it contain enough data?
- Are API calls needed to fetch remaining data?

<CodeSurfer>

```json
{
  "user_id": "baadf00d"
}
```

```json
{
  "user_id": "baadf00d",
  "email": "user@example.com",
  "organization_id": "1"
}
```

</CodeSurfer>

---

<Layout>

## Why "fat" events?

- Event Carried State Transfer
- Less processing time
- Less pressure on original service

Keep in mind:

- GDPR, security issues

</Layout>

---

<LocalImage src="images/Slim events require more communication.drawio.png" width="800px" />

---

<Layout>

## Sagas

- Coordinate steps across multiple services
- Rollback steps on failure
- Requires knowing all steps
- Requires knowing compensating action for all steps
- Two types: choreograpy and orchestration

</Layout>

---

<LocalImage src="images/Create_Order_Saga.png" width="1400px" />

(from [microservices.io](https://microservices.io/patterns/data/saga.html))

---

<Layout>

## Events and design

- Events _are_ your API, design accordingly
- Centralized documentation and repository
- Versioning
- Granularity: CRUD or hyper detailed
  - `UserCreated`, `UserBanned`, `UserUnbanned`, `UserBlocked`
  - `UserCreated`, `UserModified`, `UserDeleted`

</Layout>

---

## Options when performing actions across services

1. Sync communication (REST, gRPC)
2. Async i.e. events (fire and forget)
   - Message streams
3. Events choreograpy
4. Centralized process manager
5. BFFs

---

## Anti-patterns when using events

- Chatty events or chain events
  - Essential workflows are implicit and hard to debug
- Coupling services with complex choreograpy
  - Details might be lost, easy to break others, hard to roll out fixes
- Sagas for everything
  - Logic leaks out into API Gateway or other unknown services
- Domain leaking
  - Prefer losing context when receiving events

---

<Layout>

<LocalImage src="images/tweet_651897353889259520_20240424_113650_via_10015_io.png" width="900px" />

</Layout>

---

<Layout>

<blockquote>
  <p>
    First Law of Distributed Object Design: "don't distribute your objects".
  </p>
  &mdash; Martin Fowler &nbsp;
  <LocalImage src="mf.jpg" width="100px" />
</blockquote>

</Layout>

---

# Data access

---

## What about queries?

- Querying data inside service is simple
- Filtering, sorting, pagination across services is harder
- We really like joining data
  - Are those even relational databases?

---

## Types of reads

- Querying data from external endpoint
  - For UI, reports, public API
- Checking data as a part of the process
  - Validation, verification
- Composing data as a part of the process
  - Putting enough information into archive for easy lookup
  - E.g. address at the point of purchase

---

<Layout>

## Can I use events for reading?

- They need to cover all state changes
  - You should be able to reconstruct a valid invariant
- We shouldn't duplicate domain logic
  - How to interpret events

Alternatives:

- Data replication e.g. Debezium
- Data sync microservice

</Layout>

---

## Who owns data?

- Static data/metadata (rarely changing, external data)
  - VAT rules, countries, timezones, domain specific constant data
- Reference (master) data (usually business specific and highly important)
  - Data commonly used across microservices
- Lookup data
  - From one service to another

---

## Static data/metadata

- Ship with the app as a package (Nuget, npm, gem)
- Data management microservice (cron update)

---

<Layout>

<LocalImage src="images/Sync service.drawio.png" width="900px" />

</Layout>


---

## Reference data (master data)

- Often changing data that is used in various services
- Need to have a canonical data owner
- Create caches next to the services that need them
  - Sync via events
  - Sync via cron job
  - Anti-corruption layer to assure interesting data stays there

---

## What about JOINs?

- Filtering, Pagination, Search
- JOIN across servers is impossible
- Do it:
  1. in-app
  2. in API Gateway
  3. in a dedicated data lake/custom db

<blockquote>
  Fetch customers 21-40 which have outstanding orders sorted by last order sent.
</blockquote>

---

## Could vs Should

- You **could** `JOIN` in DB
- Is this **critical** business functionality?

---

## Accidental complexity

- Splitting systems does not remove the need for their interaction
- Required interactions become more complex
- Optional interactions complicate UX

---

## Service boundaries within a monolithic service

<LocalImage src="images/service-boundary-1.png" height="80%" />

---

## Service boundaries in modules or microservices

<LocalImage src="images/service-boundary-2.png" height="80%" />

---

## Service boundaries make operations explicit

<LocalImage src="images/service-boundary-3.png" height="80%" />

---

## Proper modules and their dependencies

<LocalImage src="images/service-boundary-4.png" height="80%" />

---

## Actual architecture

<LocalImage src="images/service-boundary-5.png" height="80%" />

---

## Recap

- Modeling distributed system is hard
- Use pain points to guide implementation and design
- Design and document events

---

<Layout style={{ gap: '1rem' }}>

## What's next?

- Testing...

<img
  style={{ marginTop: "0", height: '50vh' }}
  src="https://media.giphy.com/media/WodKaNr3eh7FudzZVb/giphy.gif"
  role="presentational"
/>

</Layout>

---

<Layout style={{ alignSelf: 'start' }}>

# Thank you!

Toni Petrina <br/>
twitter.com/tonipetrina1 <br/>
github.com/tpetrina

</Layout>
